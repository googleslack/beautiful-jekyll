"use strict";
const https = require("https");
const util = require("util");
const logless_1 = require("./logless");
const uuid = require("node-uuid");
class LoglessContext {
    constructor(_source) {
        this._source = _source;
        this._queue = [];
    }
    wrapCall(console, name, type) {
        const self = this;
        let originalCall = console[name];
        if (originalCall.logless !== undefined) {
            console.log("Already Wrapped");
            return originalCall;
        }
        let newCall = function (data) {
            let args = Array.prototype.slice.call(arguments);
            if (args.length > 1) {
                args = args.slice(1);
            }
            else {
                args = null;
            }
            self.log(type, data, args);
            originalCall.apply(this, arguments);
        };
        newCall.logless = true;
        console[name] = newCall;
    }
    onLambdaEvent(event, context, wrappedCallback) {
        const self = this;
        if (context.awsRequestId !== undefined && context.awsRequestId !== null) {
            this._transactionID = context.awsRequestId;
        }
        else {
            this._transactionID = uuid.v4();
        }
        this.wrapCall(console, "error", LogType.ERROR);
        this.wrapCall(console, "info", LogType.INFO);
        this.wrapCall(console, "log", LogType.DEBUG);
        this.wrapCall(console, "warn", LogType.WARN);
        this._uncaughtExceptionHandler = function (error) {
            console.error(error);
            self.flush();
        };
        process.on("uncaughtException", this._uncaughtExceptionHandler);
        const done = context.done;
        context.done = function (error, result) {
            self.captureResponse(error, result);
            self.flush(function () {
                self.cleanup();
                done.call(context, error, result);
            });
        };
        this.log(LogType.INFO, event, null, ["request"]);
        if (wrappedCallback !== undefined && wrappedCallback !== null) {
            this._callback = function (error, result) {
                self.captureResponse(error, result);
                self.flush(function () {
                    self.cleanup();
                    wrappedCallback.call(this, error, result);
                });
            };
        }
    }
    callback() {
        return this._callback;
    }
    log(type, data, params, tags) {
        if (data instanceof Error) {
            this.logError(type, data, tags);
        }
        else if (typeof data === "string") {
            let dataString = data;
            if (params !== undefined && params !== null) {
                let allParams = [data];
                for (let param of params) {
                    allParams.push(param);
                }
                dataString = util.format.apply(this, allParams);
            }
            this._queue.push(new Log(type, dataString, null, tags));
        }
        else {
            if (data === undefined) {
                data = null;
            }
            this._queue.push(new Log(type, data, null, tags));
        }
    }
    logError(type, error, tags) {
        let message = error.name + ": " + error.message;
        if (error.code !== undefined) {
            message += " code: " + error.code;
        }
        if (error.syscall !== undefined) {
            message += " syscall: " + error.syscall;
        }
        this._queue.push(new Log(type, message, error.stack, tags));
    }
    captureResponse(error, result) {
        if (error !== undefined && error !== null) {
            this.log(LogType.ERROR, error, null, ["response"]);
        }
        else {
            this.log(LogType.INFO, result, null, ["response"]);
        }
    }
    transactionID() {
        return this._transactionID;
    }
    cleanup() {
        process.removeListener("uncaughtException", this._uncaughtExceptionHandler);
    }
    flush(flushed) {
        const logBatch = {
            source: this._source,
            transaction_id: this.transactionID(),
            logs: new Array()
        };
        for (let log of this._queue) {
            const timestamp = log.timestampAsISOString();
            const logJSON = {
                payload: log.data,
                log_type: LogType[log.type],
                timestamp: timestamp,
            };
            if (log.tags !== undefined && log.tags !== null) {
                logJSON.tags = log.tags;
            }
            if (log.stack !== undefined && log.stack !== null) {
                logJSON.stack = log.stack;
            }
            logBatch.logs.push(logJSON);
        }
        this.transmit(logBatch, flushed);
        this._queue = [];
    }
    transmit(logBatch, flushed) {
        const dataAsString = JSON.stringify(logBatch);
        const dataLength = Buffer.byteLength(dataAsString);
        const options = {
            host: logless_1.Logless.Domain,
            path: "/v1/receive",
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Content-Length": dataLength,
                "Connection": "keep-alive"
            }
        };
        console.time("Logless.FlushTime");
        const httpRequest = https.request(options);
        httpRequest.on("error", function (error) {
            console.error(error.toString());
            if (flushed !== undefined) {
                console.timeEnd("Logless.FlushTime");
                console.log("Flushed Logs: " + logBatch.logs.length);
                flushed();
            }
        });
        httpRequest.setNoDelay(true);
        httpRequest.end(dataAsString, null, function () {
            if (flushed !== undefined) {
                console.timeEnd("Logless.FlushTime");
                console.log("Flushed Logs: " + logBatch.logs.length);
                flushed();
            }
        });
    }
}
exports.LoglessContext = LoglessContext;
(function (LogType) {
    LogType[LogType["DEBUG"] = 0] = "DEBUG";
    LogType[LogType["ERROR"] = 1] = "ERROR";
    LogType[LogType["INFO"] = 2] = "INFO";
    LogType[LogType["TRACE"] = 3] = "TRACE";
    LogType[LogType["WARN"] = 4] = "WARN";
})(exports.LogType || (exports.LogType = {}));
var LogType = exports.LogType;
class Log {
    constructor(type, data, stack, tags) {
        this.type = type;
        this.data = data;
        this.stack = stack;
        this.tags = tags;
        this._timestamp = new Date();
    }
    timestampAsISOString() {
        return this._timestamp.toISOString();
    }
}
exports.Log = Log;
//# sourceMappingURL=logless-context.js.map